diff --git a/inet.c b/inet.c
index 138c9ab..c262cf9 100755
--- a/inet.c
+++ b/inet.c
@@ -139,8 +139,13 @@ static int inet_global_toip(lua_State *L)

 int inet_optfamily(lua_State* L, int narg, const char* def)
 {
+    #if !defined(__3DS__)
     static const char* optname[] = { "unspec", "inet", "inet6", NULL };
     static int optvalue[] = { AF_UNSPEC, AF_INET, AF_INET6, 0 };
+    #else
+    static const char* optname[] = { "unspec", "inet", NULL };
+    static int optvalue[] = { AF_UNSPEC, AF_INET, 0 };
+    #endif

     return optvalue[luaL_checkoption(L, narg, def, optname)];
 }
@@ -348,10 +353,12 @@ static void inet_pushresolved(lua_State *L, struct hostent *hp)
 \*-------------------------------------------------------------------------*/
 const char *inet_trycreate(p_socket ps, int family, int type, int protocol) {
     const char *err = socket_strerror(socket_create(ps, family, type, protocol));
+    #if !defined(__3DS__)
     if (err == NULL && family == AF_INET6) {
         int yes = 1;
         setsockopt(*ps, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&yes, sizeof(yes));
     }
+    #endif
     return err;
 }

@@ -369,6 +376,7 @@ const char *inet_trydisconnect(p_socket ps, int family, p_timeout tm)
             return socket_strerror(socket_connect(ps, (SA *) &sin,
                 sizeof(sin), tm));
         }
+        #if !defined(__3DS__)
         case AF_INET6: {
             struct sockaddr_in6 sin6;
             struct in6_addr addrany = IN6ADDR_ANY_INIT;
@@ -378,6 +386,7 @@ const char *inet_trydisconnect(p_socket ps, int family, p_timeout tm)
             return socket_strerror(socket_connect(ps, (SA *) &sin6,
                 sizeof(sin6), tm));
         }
+        #endif
     }
     return NULL;
 }
@@ -436,7 +445,9 @@ const char *inet_tryaccept(p_socket server, int family, p_socket client,
 	socklen_t len;
 	t_sockaddr_storage addr;
     switch (family) {
+        #if !defined(__3DS__)
         case AF_INET6: len = sizeof(struct sockaddr_in6); break;
+        #endif
         case AF_INET: len = sizeof(struct sockaddr_in); break;
         default: len = sizeof(addr); break;
     }
diff --git a/inet.h b/inet.h
index 5618b61..f11d5ed 100644
--- a/inet.h
+++ b/inet.h
@@ -22,6 +22,10 @@
 #define LUASOCKET_INET_ATON
 #endif

+#ifndef INET6_ADDRSTRLEN
+#define INET6_ADDRSTRLEN INET_ADDRSTRLEN
+#endif
+
 #ifndef _WIN32
 #pragma GCC visibility push(hidden)
 #endif
diff --git a/makefile b/makefile
deleted file mode 100755
index 06f4d19..0000000
--- a/makefile
+++ /dev/null
@@ -1,461 +0,0 @@
-# luasocket src/makefile
-#
-# Definitions in this section can be overriden on the command line or in the
-# environment.
-#
-# These are equivalent:
-#
-#    export PLAT=linux DEBUG=DEBUG LUAV=5.2 prefix=/sw
-#    make
-#
-# and
-#
-#   make PLAT=linux DEBUG=DEBUG LUAV=5.2 prefix=/sw
-
-# PLAT: linux macosx win32 win64 mingw
-# platform to build for
-PLAT?=linux
-
-# LUAV: 5.1 5.2 5.3 5.4
-# lua version to build against
-LUAV?=5.1
-
-# MYCFLAGS: to be set by user if needed
-MYCFLAGS?=
-
-# MYLDFLAGS: to be set by user if needed
-MYLDFLAGS?=
-
-# DEBUG: NODEBUG DEBUG
-# debug mode causes luasocket to collect and returns timing information useful
-# for testing and debugging luasocket itself
-DEBUG?=NODEBUG
-
-# where lua headers are found for macosx builds
-# LUAINC_macosx:
-# /opt/local/include
-LUAINC_macosx_base?=/opt/local/include
-LUAINC_macosx?=$(LUAINC_macosx_base)/lua/$(LUAV) $(LUAINC_macosx_base)/lua$(LUAV) $(LUAINC_macosx_base)/lua-$(LUAV)
-
-# FIXME default should this default to fink or to macports?
-# What happens when more than one Lua version is installed?
-LUAPREFIX_macosx?=/opt/local
-CDIR_macosx?=lib/lua/$(LUAV)
-LDIR_macosx?=share/lua/$(LUAV)
-
-# LUAINC_linux:
-# /usr/include/lua$(LUAV)
-# /usr/local/include
-# /usr/local/include/lua$(LUAV)
-# where lua headers are found for linux builds
-LUAINC_linux_base?=/usr/include
-LUAINC_linux?=$(LUAINC_linux_base)/lua/$(LUAV) $(LUAINC_linux_base)/lua$(LUAV)
-LUAPREFIX_linux?=/usr/local
-CDIR_linux?=lib/lua/$(LUAV)
-LDIR_linux?=share/lua/$(LUAV)
-
-# LUAINC_freebsd:
-# /usr/local/include/lua$(LUAV)
-# where lua headers are found for freebsd builds
-LUAINC_freebsd_base?=/usr/local/include/
-LUAINC_freebsd?=$(LUAINC_freebsd_base)/lua/$(LUAV) $(LUAINC_freebsd_base)/lua$(LUAV)
-LUAPREFIX_freebsd?=/usr/local/
-CDIR_freebsd?=lib/lua/$(LUAV)
-LDIR_freebsd?=share/lua/$(LUAV)
-
-# where lua headers are found for mingw builds
-# LUAINC_mingw:
-# /opt/local/include
-LUAINC_mingw_base?=/usr/include
-LUAINC_mingw?=$(LUAINC_mingw_base)/lua/$(LUAV) $(LUAINC_mingw_base)/lua$(LUAV)
-LUALIB_mingw_base?=/usr/bin
-LUALIB_mingw?=$(LUALIB_mingw_base)/lua/$(LUAV)/lua$(subst .,,$(LUAV)).dll
-LUAPREFIX_mingw?=/usr
-CDIR_mingw?=lua/$(LUAV)
-LDIR_mingw?=lua/$(LUAV)/lua
-
-
-# LUAINC_win32:
-# LUALIB_win32:
-# where lua headers and libraries are found for win32 builds
-LUAPREFIX_win32?=
-LUAINC_win32?=$(LUAPREFIX_win32)/include/lua/$(LUAV) $(LUAPREFIX_win32)/include/lua$(LUAV)
-PLATFORM_win32?=Release
-CDIR_win32?=bin/lua/$(LUAV)/$(PLATFORM_win32)
-LDIR_win32?=bin/lua/$(LUAV)/$(PLATFORM_win32)/lua
-LUALIB_win32?=$(LUAPREFIX_win32)/lib/lua/$(LUAV)/$(PLATFORM_win32)
-LUALIBNAME_win32?=lua$(subst .,,$(LUAV)).lib
-
-# LUAINC_win64:
-# LUALIB_win64:
-# where lua headers and libraries are found for win64 builds
-LUAPREFIX_win64?=
-LUAINC_win64?=$(LUAPREFIX_win64)/include/lua/$(LUAV) $(LUAPREFIX_win64)/include/lua$(LUAV)
-PLATFORM_win64?=x64/Release
-CDIR_win64?=bin/lua/$(LUAV)/$(PLATFORM_win64)
-LDIR_win64?=bin/lua/$(LUAV)/$(PLATFORM_win64)/lua
-LUALIB_win64?=$(LUAPREFIX_win64)/lib/lua/$(LUAV)/$(PLATFORM_win64)
-LUALIBNAME_win64?=lua$(subst .,,$(LUAV)).lib
-
-
-# LUAINC_solaris:
-LUAINC_solaris_base?=/usr/include
-LUAINC_solaris?=$(LUAINC_solaris_base)/lua/$(LUAV) $(LUAINC_solaris_base)/lua$(LUAV)
-LUAPREFIX_solaris?=/usr/local
-CDIR_solaris?=lib/lua/$(LUAV)
-LDIR_solaris?=share/lua/$(LUAV)
-
-# prefix: /usr/local /usr /opt/local /sw
-# the top of the default install tree
-prefix?=$(LUAPREFIX_$(PLAT))
-
-CDIR?=$(CDIR_$(PLAT))
-LDIR?=$(LDIR_$(PLAT))
-
-# DESTDIR: (no default)
-# used by package managers to install into a temporary destination
-DESTDIR?=
-
-#------
-# Definitions below can be overridden on the make command line, but
-# shouldn't have to be.
-
-
-#------
-# Install directories
-#
-
-INSTALL_DIR=install -d
-INSTALL_DATA=install -m644
-INSTALL_EXEC=install
-INSTALL_TOP=$(DESTDIR)$(prefix)
-
-INSTALL_TOP_LDIR=$(INSTALL_TOP)/$(LDIR)
-INSTALL_TOP_CDIR=$(INSTALL_TOP)/$(CDIR)
-
-INSTALL_SOCKET_LDIR=$(INSTALL_TOP_LDIR)/socket
-INSTALL_SOCKET_CDIR=$(INSTALL_TOP_CDIR)/socket
-INSTALL_MIME_LDIR=$(INSTALL_TOP_LDIR)/mime
-INSTALL_MIME_CDIR=$(INSTALL_TOP_CDIR)/mime
-
-print:
-	@echo PLAT=$(PLAT)
-	@echo LUAV=$(LUAV)
-	@echo DEBUG=$(DEBUG)
-	@echo prefix=$(prefix)
-	@echo LUAINC_$(PLAT)=$(LUAINC_$(PLAT))
-	@echo LUALIB_$(PLAT)=$(LUALIB_$(PLAT))
-	@echo INSTALL_TOP_CDIR=$(INSTALL_TOP_CDIR)
-	@echo INSTALL_TOP_LDIR=$(INSTALL_TOP_LDIR)
-	@echo CFLAGS=$(CFLAGS)
-	@echo LDFLAGS=$(LDFLAGS)
-
-#------
-# Supported platforms
-#
-PLATS= macosx linux win32 win64 mingw solaris
-
-#------
-# Compiler and linker settings
-# for Mac OS X
-SO_macosx=so
-O_macosx=o
-CC_macosx=gcc
-DEF_macosx= -DLUASOCKET_$(DEBUG) -DUNIX_HAS_SUN_LEN
-CFLAGS_macosx=$(LUAINC:%=-I%) $(DEF) -Wall -O2 -fno-common
-LDFLAGS_macosx= -bundle -undefined dynamic_lookup -o
-LD_macosx=gcc
-SOCKET_macosx=usocket.o
-
-#------
-# Compiler and linker settings
-# for Linux
-SO_linux=so
-O_linux=o
-CC_linux=gcc
-DEF_linux=-DLUASOCKET_$(DEBUG)
-CFLAGS_linux=$(LUAINC:%=-I%) $(DEF) -Wall -Wshadow -Wextra \
-	-Wimplicit -O2 -ggdb3 -fpic
-LDFLAGS_linux=-O -shared -fpic -o
-LD_linux=gcc
-SOCKET_linux=usocket.o
-
-#------
-# Compiler and linker settings
-# for FreeBSD
-SO_freebsd=so
-O_freebsd=o
-CC_freebsd=gcc
-DEF_freebsd=-DLUASOCKET_$(DEBUG) -DUNIX_HAS_SUN_LEN
-CFLAGS_freebsd=$(LUAINC:%=-I%) $(DEF) -Wall -Wshadow -Wextra \
-	-Wimplicit -O2 -ggdb3 -fpic
-LDFLAGS_freebsd=-O -shared -fpic -o
-LD_freebsd=gcc
-SOCKET_freebsd=usocket.o
-
-#------
-# Compiler and linker settings
-# for Solaris
-SO_solaris=so
-O_solaris=o
-CC_solaris=gcc
-DEF_solaris=-DLUASOCKET_$(DEBUG)
-CFLAGS_solaris=$(LUAINC:%=-I%) $(DEF) -Wall -Wshadow -Wextra \
-	-Wimplicit -O2 -ggdb3 -fpic
-LDFLAGS_solaris=-lnsl -lsocket -lresolv -O -shared -fpic -o
-LD_solaris=gcc
-SOCKET_solaris=usocket.o
-
-#------
-# Compiler and linker settings
-# for MingW
-SO_mingw=dll
-O_mingw=o
-CC_mingw=gcc
-DEF_mingw= -DLUASOCKET_$(DEBUG) \
-	-DWINVER=0x0501
-CFLAGS_mingw=$(LUAINC:%=-I%) $(DEF) -Wall -O2 -fno-common
-LDFLAGS_mingw= $(LUALIB) -shared -Wl,-s -lws2_32 -o
-LD_mingw=gcc
-SOCKET_mingw=wsocket.o
-
-
-#------
-# Compiler and linker settings
-# for Win32
-SO_win32=dll
-O_win32=obj
-CC_win32=cl
-DEF_win32= //D "WIN32" //D "NDEBUG" //D "_WINDOWS" //D "_USRDLL" \
-     //D "_CRT_SECURE_NO_WARNINGS" \
-     //D "_WINDLL"  \
-     //D "LUASOCKET_$(DEBUG)"
-CFLAGS_win32=$(LUAINC:%=//I "%") $(DEF) //O2 //Ot //MD //W3 //nologo
-LDFLAGS_win32= //nologo //link //NOLOGO //DLL //INCREMENTAL:NO \
-    //MANIFEST //MANIFESTFILE:"intermediate.manifest" \
-    /MANIFESTUAC:"level='asInvoker' uiAccess='false'" \
-	//SUBSYSTEM:WINDOWS //OPT:REF //OPT:ICF //DYNAMICBASE:NO \
-    //MACHINE:X86 /LIBPATH:"$(LUALIB)" \
-	$(LUALIBNAME_win32) ws2_32.lib //OUT:
-
-LD_win32=cl
-SOCKET_win32=wsocket.obj
-
-#------
-# Compiler and linker settings
-# for Win64
-SO_win64=dll
-O_win64=obj
-CC_win64=cl
-DEF_win64= //D "WIN32" //D "NDEBUG" //D "_WINDOWS" //D "_USRDLL" \
-     //D "_CRT_SECURE_NO_WARNINGS" \
-     //D "_WINDLL"  \
-     //D "LUASOCKET_$(DEBUG)"
-CFLAGS_win64=$(LUAINC:%=//I "%") $(DEF) //O2 //Ot //MD //W3 //nologo
-LDFLAGS_win64= //nologo //link //NOLOGO //DLL //INCREMENTAL:NO \
-    //MANIFEST //MANIFESTFILE:"intermediate.manifest" \
-    /MANIFESTUAC:"level='asInvoker' uiAccess='false'" \
-	//SUBSYSTEM:WINDOWS //OPT:REF //OPT:ICF //DYNAMICBASE:NO \
-    /LIBPATH:"$(LUALIB)" \
-	$(LUALIBNAME_win64) ws2_32.lib //OUT:
-
-LD_win64=cl
-SOCKET_win64=wsocket.obj
-
-.SUFFIXES: .obj
-
-.c.obj:
-	$(CC) $(CFLAGS) //Fo"$@" //c $<
-
-#------
-# Output file names
-#
-SO=$(SO_$(PLAT))
-O=$(O_$(PLAT))
-SOCKET_V=3.0.0
-MIME_V=1.0.3
-SOCKET_SO=socket-$(SOCKET_V).$(SO)
-MIME_SO=mime-$(MIME_V).$(SO)
-UNIX_SO=unix.$(SO)
-SERIAL_SO=serial.$(SO)
-SOCKET=$(SOCKET_$(PLAT))
-
-#------
-# Settings selected for platform
-#
-CC=$(CC_$(PLAT))
-DEF=$(DEF_$(PLAT))
-CFLAGS=$(MYCFLAGS) $(CFLAGS_$(PLAT))
-LDFLAGS=$(MYLDFLAGS) $(LDFLAGS_$(PLAT))
-LD=$(LD_$(PLAT))
-LUAINC= $(LUAINC_$(PLAT))
-LUALIB= $(LUALIB_$(PLAT))
-
-#------
-# Modules belonging to socket-core
-#
-SOCKET_OBJS= \
-	luasocket.$(O) \
-	timeout.$(O) \
-	buffer.$(O) \
-	io.$(O) \
-	auxiliar.$(O) \
-	compat.$(O) \
-	options.$(O) \
-	inet.$(O) \
-	$(SOCKET) \
-	except.$(O) \
-	select.$(O) \
-	tcp.$(O) \
-	udp.$(O)
-
-#------
-# Modules belonging mime-core
-#
-MIME_OBJS= \
-	mime.$(O) \
-	compat.$(O)
-
-#------
-# Modules belonging unix (local domain sockets)
-#
-UNIX_OBJS=\
-	buffer.$(O) \
-	auxiliar.$(O) \
-	options.$(O) \
-	timeout.$(O) \
-	io.$(O) \
-	usocket.$(O) \
-	unixstream.$(O) \
-	unixdgram.$(O) \
-	compat.$(O) \
-	unix.$(O)
-
-#------
-# Modules belonging to serial (device streams)
-#
-SERIAL_OBJS=\
-	buffer.$(O) \
-	compat.$(O) \
-	auxiliar.$(O) \
-	options.$(O) \
-	timeout.$(O) \
-	io.$(O) \
-	usocket.$(O) \
-	serial.$(O)
-
-#------
-# Files to install
-#
-TO_SOCKET_LDIR= \
-	http.lua \
-	url.lua \
-	tp.lua \
-	ftp.lua \
-	headers.lua \
-	smtp.lua
-
-TO_TOP_LDIR= \
-	ltn12.lua \
-	socket.lua \
-	mime.lua
-
-#------
-# Targets
-#
-default: $(PLAT)
-
-
-freebsd:
-	$(MAKE) all-unix PLAT=freebsd
-
-macosx:
-	$(MAKE) all-unix PLAT=macosx
-
-win32:
-	$(MAKE) all PLAT=win32
-
-win64:
-	$(MAKE) all PLAT=win64
-
-linux:
-	$(MAKE) all-unix PLAT=linux
-
-mingw:
-	$(MAKE) all PLAT=mingw
-
-solaris:
-	$(MAKE) all-unix PLAT=solaris
-
-none:
-	@echo "Please run"
-	@echo "   make PLATFORM"
-	@echo "where PLATFORM is one of these:"
-	@echo "   $(PLATS)"
-
-all: $(SOCKET_SO) $(MIME_SO)
-
-$(SOCKET_SO): $(SOCKET_OBJS)
-	$(LD) $(SOCKET_OBJS) $(LDFLAGS)$@
-
-$(MIME_SO): $(MIME_OBJS)
-	$(LD) $(MIME_OBJS) $(LDFLAGS)$@
-
-all-unix: all $(UNIX_SO) $(SERIAL_SO)
-
-$(UNIX_SO): $(UNIX_OBJS)
-	$(LD) $(UNIX_OBJS) $(LDFLAGS)$@
-
-$(SERIAL_SO): $(SERIAL_OBJS)
-	$(LD) $(SERIAL_OBJS) $(LDFLAGS)$@
-
-install:
-	$(INSTALL_DIR) $(INSTALL_TOP_LDIR)
-	$(INSTALL_DATA) $(TO_TOP_LDIR) $(INSTALL_TOP_LDIR)
-	$(INSTALL_DIR) $(INSTALL_SOCKET_LDIR)
-	$(INSTALL_DATA) $(TO_SOCKET_LDIR) $(INSTALL_SOCKET_LDIR)
-	$(INSTALL_DIR) $(INSTALL_SOCKET_CDIR)
-	$(INSTALL_EXEC) $(SOCKET_SO) $(INSTALL_SOCKET_CDIR)/core.$(SO)
-	$(INSTALL_DIR) $(INSTALL_MIME_CDIR)
-	$(INSTALL_EXEC) $(MIME_SO) $(INSTALL_MIME_CDIR)/core.$(SO)
-
-install-unix: install
-	$(INSTALL_EXEC) $(UNIX_SO) $(INSTALL_SOCKET_CDIR)/$(UNIX_SO)
-	$(INSTALL_EXEC) $(SERIAL_SO) $(INSTALL_SOCKET_CDIR)/$(SERIAL_SO)
-
-local:
-	$(MAKE) install INSTALL_TOP_CDIR=.. INSTALL_TOP_LDIR=..
-
-clean:
-	rm -f $(SOCKET_SO) $(SOCKET_OBJS) $(SERIAL_OBJS)
-	rm -f $(MIME_SO) $(UNIX_SO) $(SERIAL_SO) $(MIME_OBJS) $(UNIX_OBJS)
-
-.PHONY: all $(PLATS) default clean echo none
-
-#------
-# List of dependencies
-#
-compat.$(O): compat.c compat.h
-auxiliar.$(O): auxiliar.c auxiliar.h
-buffer.$(O): buffer.c buffer.h io.h timeout.h
-except.$(O): except.c except.h
-inet.$(O): inet.c inet.h socket.h io.h timeout.h usocket.h
-io.$(O): io.c io.h timeout.h
-luasocket.$(O): luasocket.c luasocket.h auxiliar.h except.h \
-	timeout.h buffer.h io.h inet.h socket.h usocket.h tcp.h \
-	udp.h select.h
-mime.$(O): mime.c mime.h
-options.$(O): options.c auxiliar.h options.h socket.h io.h \
-	timeout.h usocket.h inet.h
-select.$(O): select.c socket.h io.h timeout.h usocket.h select.h
-serial.$(O): serial.c auxiliar.h socket.h io.h timeout.h usocket.h \
-  options.h unix.h buffer.h
-tcp.$(O): tcp.c auxiliar.h socket.h io.h timeout.h usocket.h \
-	inet.h options.h tcp.h buffer.h
-timeout.$(O): timeout.c auxiliar.h timeout.h
-udp.$(O): udp.c auxiliar.h socket.h io.h timeout.h usocket.h \
-	inet.h options.h udp.h
-unix.$(O): unix.c auxiliar.h socket.h io.h timeout.h usocket.h \
-	options.h unix.h buffer.h
-usocket.$(O): usocket.c socket.h io.h timeout.h usocket.h
-wsocket.$(O): wsocket.c socket.h io.h timeout.h usocket.h
diff --git a/options.c b/options.c
index 3280c51..9a45e6f 100644
--- a/options.c
+++ b/options.c
@@ -22,6 +22,22 @@ static int opt_set(lua_State *L, p_socket ps, int level, int name,
 static int opt_get(lua_State *L, p_socket ps, int level, int name,
         void *val, int* len);

+static int set_opt_error(lua_State* L)
+{
+    lua_pushnil(L);
+    lua_pushstring(L, "setsockopt failed: not supported");
+
+    return 2;
+}
+
+static int get_opt_error(lua_State* L)
+{
+    lua_pushnil(L);
+    lua_pushstring(L, "getsockopt failed: not supported");
+
+    return 2;
+}
+
 /*=========================================================================*\
 * Exported functions
 \*=========================================================================*/
@@ -136,6 +152,7 @@ int opt_set_tcp_keepintvl(lua_State *L, p_socket ps)
 #endif

 /*------------------------------------------------------*/
+#if !defined(__3DS__)
 int opt_set_keepalive(lua_State *L, p_socket ps)
 {
     return opt_setboolean(L, ps, SOL_SOCKET, SO_KEEPALIVE);
@@ -167,6 +184,16 @@ int opt_get_broadcast(lua_State *L, p_socket ps)
 {
     return opt_getboolean(L, ps, SOL_SOCKET, SO_BROADCAST);
 }
+#else
+int opt_set_keepalive(lua_State *L, p_socket ps) { return set_opt_error(L); }
+int opt_get_keepalive(lua_State *L, p_socket ps) { return get_opt_error(L); }
+
+int opt_set_dontroute(lua_State *L, p_socket ps) { return set_opt_error(L); }
+int opt_get_dontroute(lua_State *L, p_socket ps) { return get_opt_error(L); }
+
+int opt_set_broadcast(lua_State *L, p_socket ps) { return set_opt_error(L); }
+int opt_get_broadcast(lua_State *L, p_socket ps) { return get_opt_error(L); }
+#endif

 /*------------------------------------------------------*/
 int opt_set_recv_buf_size(lua_State *L, p_socket ps)
@@ -216,6 +243,7 @@ int opt_set_tcp_defer_accept(lua_State *L, p_socket ps)
 #endif

 /*------------------------------------------------------*/
+#if !defined(__3DS__)
 int opt_set_ip6_unicast_hops(lua_State *L, p_socket ps)
 {
   return opt_setint(L, ps, IPPROTO_IPV6, IPV6_UNICAST_HOPS);
@@ -236,6 +264,13 @@ int opt_get_ip6_multicast_hops(lua_State *L, p_socket ps)
 {
   return opt_getint(L, ps, IPPROTO_IPV6, IPV6_MULTICAST_HOPS);
 }
+#else
+int opt_set_ip6_unicast_hops(lua_State *L, p_socket ps) { return set_opt_error(L); }
+int opt_get_ip6_unicast_hops(lua_State *L, p_socket ps) { return get_opt_error(L); }
+
+int opt_set_ip6_multicast_hops(lua_State *L, p_socket ps) { return set_opt_error(L); }
+int opt_get_ip6_multicast_hops(lua_State *L, p_socket ps) { return get_opt_error(L); }
+#endif

 /*------------------------------------------------------*/
 int opt_set_ip_multicast_loop(lua_State *L, p_socket ps)
@@ -249,6 +284,7 @@ int opt_get_ip_multicast_loop(lua_State *L, p_socket ps)
 }

 /*------------------------------------------------------*/
+#if !defined(__3DS__)
 int opt_set_ip6_multicast_loop(lua_State *L, p_socket ps)
 {
     return opt_setboolean(L, ps, IPPROTO_IPV6, IPV6_MULTICAST_LOOP);
@@ -258,6 +294,10 @@ int opt_get_ip6_multicast_loop(lua_State *L, p_socket ps)
 {
     return opt_getboolean(L, ps, IPPROTO_IPV6, IPV6_MULTICAST_LOOP);
 }
+#else
+int opt_set_ip6_multicast_loop(lua_State *L, p_socket ps) { return set_opt_error(L); }
+int opt_get_ip6_multicast_loop(lua_State *L, p_socket ps) { return get_opt_error(L); }
+#endif

 /*------------------------------------------------------*/
 int opt_set_linger(lua_State *L, p_socket ps)
@@ -299,6 +339,7 @@ int opt_set_ip_multicast_ttl(lua_State *L, p_socket ps)
 }

 /*------------------------------------------------------*/
+#if !defined(__3DS__)
 int opt_set_ip_multicast_if(lua_State *L, p_socket ps)
 {
     const char *address = luaL_checkstring(L, 3);    /* obj, name, ip */
@@ -322,6 +363,10 @@ int opt_get_ip_multicast_if(lua_State *L, p_socket ps)
     lua_pushstring(L, inet_ntoa(val));
     return 1;
 }
+#else
+int opt_set_ip_multicast_if(lua_State *L, p_socket ps) { return set_opt_error(L); }
+int opt_get_ip_multicast_if(lua_State *L, p_socket ps) { return get_opt_error(L); }
+#endif

 /*------------------------------------------------------*/
 int opt_set_ip_add_membership(lua_State *L, p_socket ps)
@@ -335,6 +380,7 @@ int opt_set_ip_drop_membersip(lua_State *L, p_socket ps)
 }

 /*------------------------------------------------------*/
+#if !defined(__3DS__)
 int opt_set_ip6_add_membership(lua_State *L, p_socket ps)
 {
     return opt_ip6_setmembership(L, ps, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP);
@@ -355,7 +401,13 @@ int opt_set_ip6_v6only(lua_State *L, p_socket ps)
 {
     return opt_setboolean(L, ps, IPPROTO_IPV6, IPV6_V6ONLY);
 }
+#else
+int opt_set_ip6_add_membership(lua_State *L, p_socket ps) { return set_opt_error(L); }
+int opt_set_ip6_drop_membersip(lua_State *L, p_socket ps) { return set_opt_error(L); }

+int opt_get_ip6_v6only(lua_State *L, p_socket ps) { return get_opt_error(L); }
+int opt_set_ip6_v6only(lua_State *L, p_socket ps) { return set_opt_error(L); }
+#endif
 /*------------------------------------------------------*/
 int opt_get_error(lua_State *L, p_socket ps)
 {
@@ -394,6 +446,7 @@ static int opt_setmembership(lua_State *L, p_socket ps, int level, int name)
     return opt_set(L, ps, level, name, (char *) &val, sizeof(val));
 }

+#if !defined(__3DS__)
 static int opt_ip6_setmembership(lua_State *L, p_socket ps, int level, int name)
 {
     struct ipv6_mreq val;                   /* obj, opt-name, table */
@@ -419,6 +472,12 @@ static int opt_ip6_setmembership(lua_State *L, p_socket ps, int level, int name)
     }
     return opt_set(L, ps, level, name, (char *) &val, sizeof(val));
 }
+#else
+static int opt_ip6_setmembership(lua_State *L, p_socket ps, int level, int name)
+{
+    return set_opt_error(L);
+}
+#endif

 static
 int opt_get(lua_State *L, p_socket ps, int level, int name, void *val, int* len)
diff --git a/serial.c b/serial.c
deleted file mode 100644
index 21485d3..0000000
--- a/serial.c
+++ /dev/null
@@ -1,171 +0,0 @@
-/*=========================================================================*\
-* Serial stream
-* LuaSocket toolkit
-\*=========================================================================*/
-#include "luasocket.h"
-
-#include "auxiliar.h"
-#include "socket.h"
-#include "options.h"
-#include "unix.h"
-
-#include <string.h>
-#include <sys/un.h>
-
-/*
-Reuses userdata definition from unix.h, since it is useful for all
-stream-like objects.
-
-If we stored the serial path for use in error messages or userdata
-printing, we might need our own userdata definition.
-
-Group usage is semi-inherited from unix.c, but unnecessary since we
-have only one object type.
-*/
-
-/*=========================================================================*\
-* Internal function prototypes
-\*=========================================================================*/
-static int global_create(lua_State *L);
-static int meth_send(lua_State *L);
-static int meth_receive(lua_State *L);
-static int meth_close(lua_State *L);
-static int meth_settimeout(lua_State *L);
-static int meth_getfd(lua_State *L);
-static int meth_setfd(lua_State *L);
-static int meth_dirty(lua_State *L);
-static int meth_getstats(lua_State *L);
-static int meth_setstats(lua_State *L);
-
-/* serial object methods */
-static luaL_Reg serial_methods[] = {
-    {"__gc",        meth_close},
-    {"__tostring",  auxiliar_tostring},
-    {"close",       meth_close},
-    {"dirty",       meth_dirty},
-    {"getfd",       meth_getfd},
-    {"getstats",    meth_getstats},
-    {"setstats",    meth_setstats},
-    {"receive",     meth_receive},
-    {"send",        meth_send},
-    {"setfd",       meth_setfd},
-    {"settimeout",  meth_settimeout},
-    {NULL,          NULL}
-};
-
-/*-------------------------------------------------------------------------*\
-* Initializes module
-\*-------------------------------------------------------------------------*/
-LUASOCKET_API int luaopen_socket_serial(lua_State *L) {
-    /* create classes */
-    auxiliar_newclass(L, "serial{client}", serial_methods);
-    /* create class groups */
-    auxiliar_add2group(L, "serial{client}", "serial{any}");
-    lua_pushcfunction(L, global_create);
-    return 1;
-}
-
-/*=========================================================================*\
-* Lua methods
-\*=========================================================================*/
-/*-------------------------------------------------------------------------*\
-* Just call buffered IO methods
-\*-------------------------------------------------------------------------*/
-static int meth_send(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1);
-    return buffer_meth_send(L, &un->buf);
-}
-
-static int meth_receive(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1);
-    return buffer_meth_receive(L, &un->buf);
-}
-
-static int meth_getstats(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1);
-    return buffer_meth_getstats(L, &un->buf);
-}
-
-static int meth_setstats(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1);
-    return buffer_meth_setstats(L, &un->buf);
-}
-
-/*-------------------------------------------------------------------------*\
-* Select support methods
-\*-------------------------------------------------------------------------*/
-static int meth_getfd(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
-    lua_pushnumber(L, (int) un->sock);
-    return 1;
-}
-
-/* this is very dangerous, but can be handy for those that are brave enough */
-static int meth_setfd(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
-    un->sock = (t_socket) luaL_checknumber(L, 2);
-    return 0;
-}
-
-static int meth_dirty(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
-    lua_pushboolean(L, !buffer_isempty(&un->buf));
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Closes socket used by object
-\*-------------------------------------------------------------------------*/
-static int meth_close(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
-    socket_destroy(&un->sock);
-    lua_pushnumber(L, 1);
-    return 1;
-}
-
-
-/*-------------------------------------------------------------------------*\
-* Just call tm methods
-\*-------------------------------------------------------------------------*/
-static int meth_settimeout(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
-    return timeout_meth_settimeout(L, &un->tm);
-}
-
-/*=========================================================================*\
-* Library functions
-\*=========================================================================*/
-
-
-/*-------------------------------------------------------------------------*\
-* Creates a serial object
-\*-------------------------------------------------------------------------*/
-static int global_create(lua_State *L) {
-    const char* path = luaL_checkstring(L, 1);
-
-    /* allocate unix object */
-    p_unix un = (p_unix) lua_newuserdata(L, sizeof(t_unix));
-
-    /* open serial device */
-    t_socket sock = open(path, O_NOCTTY|O_RDWR);
-
-    /*printf("open %s on %d\n", path, sock);*/
-
-    if (sock < 0)  {
-        lua_pushnil(L);
-        lua_pushstring(L, socket_strerror(errno));
-        lua_pushnumber(L, errno);
-        return 3;
-    }
-    /* set its type as client object */
-    auxiliar_setclass(L, "serial{client}", -1);
-    /* initialize remaining structure fields */
-    socket_setnonblocking(&sock);
-    un->sock = sock;
-    io_init(&un->io, (p_send) socket_write, (p_recv) socket_read,
-            (p_error) socket_ioerror, &un->sock);
-    timeout_init(&un->tm, -1, -1);
-    buffer_init(&un->buf, &un->io, &un->tm);
-    return 1;
-}
diff --git a/tcp.c b/tcp.c
index e84db84..9dfa27e 100644
--- a/tcp.c
+++ b/tcp.c
@@ -427,9 +427,18 @@ static int global_create4(lua_State *L) {
     return tcp_create(L, AF_INET);
 }

+#if !defined(__3DS__)
 static int global_create6(lua_State *L) {
     return tcp_create(L, AF_INET6);
 }
+#else
+static int global_create6(lua_State* L) {
+    lua_pushnil(L);
+    lua_pushstring(L, "Setting local interface error: not supported");
+
+    return 2;
+}
+#endif

 static int global_connect(lua_State *L) {
     const char *remoteaddr = luaL_checkstring(L, 1);
diff --git a/udp.c b/udp.c
index 712ad50..a3c7a5f 100755
--- a/udp.c
+++ b/udp.c
@@ -483,6 +483,15 @@ static int global_create4(lua_State *L) {
     return udp_create(L, AF_INET);
 }

+#if !defined(__3DS__)
 static int global_create6(lua_State *L) {
     return udp_create(L, AF_INET6);
 }
+#else
+static int global_create6(lua_State *L) {
+    lua_pushnil(L);
+    lua_pushstring(L, "Setting local interface error: not supported");
+
+    return 2;
+}
+#endif
diff --git a/unix.c b/unix.c
deleted file mode 100644
index 268d8b2..0000000
--- a/unix.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*=========================================================================*\
-* Unix domain socket
-* LuaSocket toolkit
-\*=========================================================================*/
-#include "luasocket.h"
-
-#include "unixstream.h"
-#include "unixdgram.h"
-
-/*-------------------------------------------------------------------------*\
-* Modules and functions
-\*-------------------------------------------------------------------------*/
-static const luaL_Reg mod[] = {
-    {"stream", unixstream_open},
-    {"dgram", unixdgram_open},
-    {NULL, NULL}
-};
-
-static void add_alias(lua_State *L, int index, const char *name, const char *target)
-{
-    lua_getfield(L, index, target);
-    lua_setfield(L, index, name);
-}
-
-static int compat_socket_unix_call(lua_State *L)
-{
-    /* Look up socket.unix.stream in the socket.unix table (which is the first
-     * argument). */
-    lua_getfield(L, 1, "stream");
-
-    /* Replace the stack entry for the socket.unix table with the
-     * socket.unix.stream function. */
-    lua_replace(L, 1);
-
-    /* Call socket.unix.stream, passing along any arguments. */
-    int n = lua_gettop(L);
-    lua_call(L, n-1, LUA_MULTRET);
-
-    /* Pass along the return values from socket.unix.stream. */
-    n = lua_gettop(L);
-    return n;
-}
-
-/*-------------------------------------------------------------------------*\
-* Initializes module
-\*-------------------------------------------------------------------------*/
-LUASOCKET_API int luaopen_socket_unix(lua_State *L)
-{
-    int i;
-    lua_newtable(L);
-    int socket_unix_table = lua_gettop(L);
-
-    for (i = 0; mod[i].name; i++)
-        mod[i].func(L);
-
-    /* Add backwards compatibility aliases "tcp" and "udp" for the "stream" and
-     * "dgram" functions. */
-    add_alias(L, socket_unix_table, "tcp", "stream");
-    add_alias(L, socket_unix_table, "udp", "dgram");
-
-    /* Add a backwards compatibility function and a metatable setup to call it
-     * for the old socket.unix() interface. */
-    lua_pushcfunction(L, compat_socket_unix_call);
-    lua_setfield(L, socket_unix_table, "__call");
-    lua_pushvalue(L, socket_unix_table);
-    lua_setmetatable(L, socket_unix_table);
-
-    return 1;
-}
diff --git a/unix.h b/unix.h
deleted file mode 100644
index c203561..0000000
--- a/unix.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef UNIX_H
-#define UNIX_H
-/*=========================================================================*\
-* Unix domain object
-* LuaSocket toolkit
-*
-* This module is just an example of how to extend LuaSocket with a new
-* domain.
-\*=========================================================================*/
-#include "luasocket.h"
-
-#include "buffer.h"
-#include "timeout.h"
-#include "socket.h"
-
-typedef struct t_unix_ {
-    t_socket sock;
-    t_io io;
-    t_buffer buf;
-    t_timeout tm;
-} t_unix;
-typedef t_unix *p_unix;
-
-LUASOCKET_API int luaopen_socket_unix(lua_State *L);
-
-#endif /* UNIX_H */
diff --git a/unixdgram.c b/unixdgram.c
deleted file mode 100644
index 69093d7..0000000
--- a/unixdgram.c
+++ /dev/null
@@ -1,405 +0,0 @@
-/*=========================================================================*\
-* Unix domain socket dgram submodule
-* LuaSocket toolkit
-\*=========================================================================*/
-#include "luasocket.h"
-
-#include "auxiliar.h"
-#include "socket.h"
-#include "options.h"
-#include "unix.h"
-
-#include <string.h>
-#include <stdlib.h>
-
-#include <sys/un.h>
-
-#define UNIXDGRAM_DATAGRAMSIZE 8192
-
-/* provide a SUN_LEN macro if sys/un.h doesn't (e.g. Android) */
-#ifndef SUN_LEN
-#define SUN_LEN(ptr) \
-  ((size_t) (((struct sockaddr_un *) 0)->sun_path)  \
-   + strlen ((ptr)->sun_path))
-#endif
-
-/*=========================================================================*\
-* Internal function prototypes
-\*=========================================================================*/
-static int global_create(lua_State *L);
-static int meth_connect(lua_State *L);
-static int meth_bind(lua_State *L);
-static int meth_send(lua_State *L);
-static int meth_receive(lua_State *L);
-static int meth_close(lua_State *L);
-static int meth_setoption(lua_State *L);
-static int meth_settimeout(lua_State *L);
-static int meth_gettimeout(lua_State *L);
-static int meth_getfd(lua_State *L);
-static int meth_setfd(lua_State *L);
-static int meth_dirty(lua_State *L);
-static int meth_receivefrom(lua_State *L);
-static int meth_sendto(lua_State *L);
-static int meth_getsockname(lua_State *L);
-
-static const char *unixdgram_tryconnect(p_unix un, const char *path);
-static const char *unixdgram_trybind(p_unix un, const char *path);
-
-/* unixdgram object methods */
-static luaL_Reg unixdgram_methods[] = {
-    {"__gc",        meth_close},
-    {"__tostring",  auxiliar_tostring},
-    {"bind",        meth_bind},
-    {"close",       meth_close},
-    {"connect",     meth_connect},
-    {"dirty",       meth_dirty},
-    {"getfd",       meth_getfd},
-    {"send",        meth_send},
-    {"sendto",      meth_sendto},
-    {"receive",     meth_receive},
-    {"receivefrom", meth_receivefrom},
-    {"setfd",       meth_setfd},
-    {"setoption",   meth_setoption},
-    {"setpeername", meth_connect},
-    {"setsockname", meth_bind},
-    {"getsockname", meth_getsockname},
-    {"settimeout",  meth_settimeout},
-    {"gettimeout",  meth_gettimeout},
-    {NULL,          NULL}
-};
-
-/* socket option handlers */
-static t_opt optset[] = {
-    {"reuseaddr",   opt_set_reuseaddr},
-    {NULL,          NULL}
-};
-
-/* functions in library namespace */
-static luaL_Reg func[] = {
-    {"dgram", global_create},
-    {NULL, NULL}
-};
-
-/*-------------------------------------------------------------------------*\
-* Initializes module
-\*-------------------------------------------------------------------------*/
-int unixdgram_open(lua_State *L)
-{
-    /* create classes */
-    auxiliar_newclass(L, "unixdgram{connected}", unixdgram_methods);
-    auxiliar_newclass(L, "unixdgram{unconnected}", unixdgram_methods);
-    /* create class groups */
-    auxiliar_add2group(L, "unixdgram{connected}",   "unixdgram{any}");
-    auxiliar_add2group(L, "unixdgram{unconnected}", "unixdgram{any}");
-    auxiliar_add2group(L, "unixdgram{connected}",   "select{able}");
-    auxiliar_add2group(L, "unixdgram{unconnected}", "select{able}");
-
-    luaL_setfuncs(L, func, 0);
-    return 0;
-}
-
-/*=========================================================================*\
-* Lua methods
-\*=========================================================================*/
-static const char *unixdgram_strerror(int err)
-{
-    /* a 'closed' error on an unconnected means the target address was not
-     * accepted by the transport layer */
-    if (err == IO_CLOSED) return "refused";
-    else return socket_strerror(err);
-}
-
-static int meth_send(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixdgram{connected}", 1);
-    p_timeout tm = &un->tm;
-    size_t count, sent = 0;
-    int err;
-    const char *data = luaL_checklstring(L, 2, &count);
-    timeout_markstart(tm);
-    err = socket_send(&un->sock, data, count, &sent, tm);
-    if (err != IO_DONE) {
-        lua_pushnil(L);
-        lua_pushstring(L, unixdgram_strerror(err));
-        return 2;
-    }
-    lua_pushnumber(L, (lua_Number) sent);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Send data through unconnected unixdgram socket
-\*-------------------------------------------------------------------------*/
-static int meth_sendto(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixdgram{unconnected}", 1);
-    size_t count, sent = 0;
-    const char *data = luaL_checklstring(L, 2, &count);
-    const char *path = luaL_checkstring(L, 3);
-    p_timeout tm = &un->tm;
-    int err;
-    struct sockaddr_un remote;
-    size_t len = strlen(path);
-
-    if (len >= sizeof(remote.sun_path)) {
-		lua_pushnil(L);
-		lua_pushstring(L, "path too long");
-		return 2;
-	}
-
-    memset(&remote, 0, sizeof(remote));
-    strcpy(remote.sun_path, path);
-    remote.sun_family = AF_UNIX;
-    timeout_markstart(tm);
-#ifdef UNIX_HAS_SUN_LEN
-    remote.sun_len = sizeof(remote.sun_family) + sizeof(remote.sun_len)
-        + len + 1;
-    err = socket_sendto(&un->sock, data, count, &sent, (SA *) &remote, remote.sun_len, tm);
-#else
-    err = socket_sendto(&un->sock, data, count, &sent, (SA *) &remote,
-		   	sizeof(remote.sun_family) + len, tm);
-#endif
-    if (err != IO_DONE) {
-        lua_pushnil(L);
-        lua_pushstring(L, unixdgram_strerror(err));
-        return 2;
-    }
-    lua_pushnumber(L, (lua_Number) sent);
-    return 1;
-}
-
-static int meth_receive(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    char buf[UNIXDGRAM_DATAGRAMSIZE];
-    size_t got, wanted = (size_t) luaL_optnumber(L, 2, sizeof(buf));
-    char *dgram = wanted > sizeof(buf)? (char *) malloc(wanted): buf;
-    int err;
-    p_timeout tm = &un->tm;
-    timeout_markstart(tm);
-    if (!dgram) {
-        lua_pushnil(L);
-        lua_pushliteral(L, "out of memory");
-        return 2;
-    }
-    err = socket_recv(&un->sock, dgram, wanted, &got, tm);
-    /* Unlike STREAM, recv() of zero is not closed, but a zero-length packet. */
-    if (err != IO_DONE && err != IO_CLOSED) {
-        lua_pushnil(L);
-        lua_pushstring(L, unixdgram_strerror(err));
-        if (wanted > sizeof(buf)) free(dgram);
-        return 2;
-    }
-    lua_pushlstring(L, dgram, got);
-    if (wanted > sizeof(buf)) free(dgram);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Receives data and sender from a DGRAM socket
-\*-------------------------------------------------------------------------*/
-static int meth_receivefrom(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixdgram{unconnected}", 1);
-    char buf[UNIXDGRAM_DATAGRAMSIZE];
-    size_t got, wanted = (size_t) luaL_optnumber(L, 2, sizeof(buf));
-    char *dgram = wanted > sizeof(buf)? (char *) malloc(wanted): buf;
-    struct sockaddr_un addr;
-    socklen_t addr_len = sizeof(addr);
-    int err;
-    p_timeout tm = &un->tm;
-    timeout_markstart(tm);
-    if (!dgram) {
-        lua_pushnil(L);
-        lua_pushliteral(L, "out of memory");
-        return 2;
-    }
-    addr.sun_path[0] = '\0';
-    err = socket_recvfrom(&un->sock, dgram, wanted, &got, (SA *) &addr,
-            &addr_len, tm);
-    /* Unlike STREAM, recv() of zero is not closed, but a zero-length packet. */
-    if (err != IO_DONE && err != IO_CLOSED) {
-        lua_pushnil(L);
-        lua_pushstring(L, unixdgram_strerror(err));
-        if (wanted > sizeof(buf)) free(dgram);
-        return 2;
-    }
-
-    lua_pushlstring(L, dgram, got);
-	/* the path may be empty, when client send without bind */
-    lua_pushstring(L, addr.sun_path);
-    if (wanted > sizeof(buf)) free(dgram);
-    return 2;
-}
-
-/*-------------------------------------------------------------------------*\
-* Just call option handler
-\*-------------------------------------------------------------------------*/
-static int meth_setoption(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    return opt_meth_setoption(L, optset, &un->sock);
-}
-
-/*-------------------------------------------------------------------------*\
-* Select support methods
-\*-------------------------------------------------------------------------*/
-static int meth_getfd(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    lua_pushnumber(L, (int) un->sock);
-    return 1;
-}
-
-/* this is very dangerous, but can be handy for those that are brave enough */
-static int meth_setfd(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    un->sock = (t_socket) luaL_checknumber(L, 2);
-    return 0;
-}
-
-static int meth_dirty(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    (void) un;
-    lua_pushboolean(L, 0);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Binds an object to an address
-\*-------------------------------------------------------------------------*/
-static const char *unixdgram_trybind(p_unix un, const char *path) {
-    struct sockaddr_un local;
-    size_t len = strlen(path);
-    if (len >= sizeof(local.sun_path)) return "path too long";
-    memset(&local, 0, sizeof(local));
-    strcpy(local.sun_path, path);
-    local.sun_family = AF_UNIX;
-    size_t addrlen = SUN_LEN(&local);
-#ifdef UNIX_HAS_SUN_LEN
-    local.sun_len = addrlen + 1;
-#endif
-    int err = socket_bind(&un->sock, (SA *) &local, addrlen);
-    if (err != IO_DONE) socket_destroy(&un->sock);
-    return socket_strerror(err);
-}
-
-static int meth_bind(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixdgram{unconnected}", 1);
-    const char *path =  luaL_checkstring(L, 2);
-    const char *err = unixdgram_trybind(un, path);
-    if (err) {
-        lua_pushnil(L);
-        lua_pushstring(L, err);
-        return 2;
-    }
-    lua_pushnumber(L, 1);
-    return 1;
-}
-
-static int meth_getsockname(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    struct sockaddr_un peer = {0};
-    socklen_t peer_len = sizeof(peer);
-
-    if (getsockname(un->sock, (SA *) &peer, &peer_len) < 0) {
-        lua_pushnil(L);
-        lua_pushstring(L, socket_strerror(errno));
-        return 2;
-    }
-
-    lua_pushstring(L, peer.sun_path);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Turns a master unixdgram object into a client object.
-\*-------------------------------------------------------------------------*/
-static const char *unixdgram_tryconnect(p_unix un, const char *path)
-{
-    struct sockaddr_un remote;
-    size_t len = strlen(path);
-    if (len >= sizeof(remote.sun_path)) return "path too long";
-    memset(&remote, 0, sizeof(remote));
-    strcpy(remote.sun_path, path);
-    remote.sun_family = AF_UNIX;
-    timeout_markstart(&un->tm);
-    size_t addrlen = SUN_LEN(&remote);
-#ifdef UNIX_HAS_SUN_LEN
-    remote.sun_len = addrlen + 1;
-#endif
-    int err = socket_connect(&un->sock, (SA *) &remote, addrlen, &un->tm);
-    if (err != IO_DONE) socket_destroy(&un->sock);
-    return socket_strerror(err);
-}
-
-static int meth_connect(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    const char *path =  luaL_checkstring(L, 2);
-    const char *err = unixdgram_tryconnect(un, path);
-    if (err) {
-        lua_pushnil(L);
-        lua_pushstring(L, err);
-        return 2;
-    }
-    /* turn unconnected object into a connected object */
-    auxiliar_setclass(L, "unixdgram{connected}", 1);
-    lua_pushnumber(L, 1);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Closes socket used by object
-\*-------------------------------------------------------------------------*/
-static int meth_close(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    socket_destroy(&un->sock);
-    lua_pushnumber(L, 1);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Just call tm methods
-\*-------------------------------------------------------------------------*/
-static int meth_settimeout(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    return timeout_meth_settimeout(L, &un->tm);
-}
-
-static int meth_gettimeout(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixdgram{any}", 1);
-    return timeout_meth_gettimeout(L, &un->tm);
-}
-
-/*=========================================================================*\
-* Library functions
-\*=========================================================================*/
-/*-------------------------------------------------------------------------*\
-* Creates a master unixdgram object
-\*-------------------------------------------------------------------------*/
-static int global_create(lua_State *L)
-{
-    t_socket sock;
-    int err = socket_create(&sock, AF_UNIX, SOCK_DGRAM, 0);
-    /* try to allocate a system socket */
-    if (err == IO_DONE) {
-        /* allocate unixdgram object */
-        p_unix un = (p_unix) lua_newuserdata(L, sizeof(t_unix));
-        /* set its type as master object */
-        auxiliar_setclass(L, "unixdgram{unconnected}", -1);
-        /* initialize remaining structure fields */
-        socket_setnonblocking(&sock);
-        un->sock = sock;
-        io_init(&un->io, (p_send) socket_send, (p_recv) socket_recv,
-                (p_error) socket_ioerror, &un->sock);
-        timeout_init(&un->tm, -1, -1);
-        buffer_init(&un->buf, &un->io, &un->tm);
-        return 1;
-    } else {
-        lua_pushnil(L);
-        lua_pushstring(L, socket_strerror(err));
-        return 2;
-    }
-}
diff --git a/unixdgram.h b/unixdgram.h
deleted file mode 100644
index a1a0166..0000000
--- a/unixdgram.h
+++ /dev/null
@@ -1,28 +0,0 @@
-#ifndef UNIXDGRAM_H
-#define UNIXDGRAM_H
-/*=========================================================================*\
-* DGRAM object
-* LuaSocket toolkit
-*
-* The dgram.h module provides LuaSocket with support for DGRAM protocol
-* (AF_INET, SOCK_DGRAM).
-*
-* Two classes are defined: connected and unconnected. DGRAM objects are
-* originally unconnected. They can be "connected" to a given address
-* with a call to the setpeername function. The same function can be used to
-* break the connection.
-\*=========================================================================*/
-
-#include "unix.h"
-
-#ifndef _WIN32
-#pragma GCC visibility push(hidden)
-#endif
-
-int unixdgram_open(lua_State *L);
-
-#ifndef _WIN32
-#pragma GCC visibility pop
-#endif
-
-#endif /* UNIXDGRAM_H */
diff --git a/unixstream.c b/unixstream.c
deleted file mode 100644
index 02aced9..0000000
--- a/unixstream.c
+++ /dev/null
@@ -1,355 +0,0 @@
-/*=========================================================================*\
-* Unix domain socket stream sub module
-* LuaSocket toolkit
-\*=========================================================================*/
-#include "luasocket.h"
-
-#include "auxiliar.h"
-#include "socket.h"
-#include "options.h"
-#include "unixstream.h"
-
-#include <string.h>
-#include <sys/un.h>
-
-/*=========================================================================*\
-* Internal function prototypes
-\*=========================================================================*/
-static int global_create(lua_State *L);
-static int meth_connect(lua_State *L);
-static int meth_listen(lua_State *L);
-static int meth_bind(lua_State *L);
-static int meth_send(lua_State *L);
-static int meth_shutdown(lua_State *L);
-static int meth_receive(lua_State *L);
-static int meth_accept(lua_State *L);
-static int meth_close(lua_State *L);
-static int meth_setoption(lua_State *L);
-static int meth_settimeout(lua_State *L);
-static int meth_getfd(lua_State *L);
-static int meth_setfd(lua_State *L);
-static int meth_dirty(lua_State *L);
-static int meth_getstats(lua_State *L);
-static int meth_setstats(lua_State *L);
-static int meth_getsockname(lua_State *L);
-
-static const char *unixstream_tryconnect(p_unix un, const char *path);
-static const char *unixstream_trybind(p_unix un, const char *path);
-
-/* unixstream object methods */
-static luaL_Reg unixstream_methods[] = {
-    {"__gc",        meth_close},
-    {"__tostring",  auxiliar_tostring},
-    {"accept",      meth_accept},
-    {"bind",        meth_bind},
-    {"close",       meth_close},
-    {"connect",     meth_connect},
-    {"dirty",       meth_dirty},
-    {"getfd",       meth_getfd},
-    {"getstats",    meth_getstats},
-    {"setstats",    meth_setstats},
-    {"listen",      meth_listen},
-    {"receive",     meth_receive},
-    {"send",        meth_send},
-    {"setfd",       meth_setfd},
-    {"setoption",   meth_setoption},
-    {"setpeername", meth_connect},
-    {"setsockname", meth_bind},
-    {"getsockname", meth_getsockname},
-    {"settimeout",  meth_settimeout},
-    {"shutdown",    meth_shutdown},
-    {NULL,          NULL}
-};
-
-/* socket option handlers */
-static t_opt optset[] = {
-    {"keepalive",   opt_set_keepalive},
-    {"reuseaddr",   opt_set_reuseaddr},
-    {"linger",      opt_set_linger},
-    {NULL,          NULL}
-};
-
-/* functions in library namespace */
-static luaL_Reg func[] = {
-    {"stream", global_create},
-    {NULL, NULL}
-};
-
-/*-------------------------------------------------------------------------*\
-* Initializes module
-\*-------------------------------------------------------------------------*/
-int unixstream_open(lua_State *L)
-{
-    /* create classes */
-    auxiliar_newclass(L, "unixstream{master}", unixstream_methods);
-    auxiliar_newclass(L, "unixstream{client}", unixstream_methods);
-    auxiliar_newclass(L, "unixstream{server}", unixstream_methods);
-
-    /* create class groups */
-    auxiliar_add2group(L, "unixstream{master}", "unixstream{any}");
-    auxiliar_add2group(L, "unixstream{client}", "unixstream{any}");
-    auxiliar_add2group(L, "unixstream{server}", "unixstream{any}");
-
-    luaL_setfuncs(L, func, 0);
-    return 0;
-}
-
-/*=========================================================================*\
-* Lua methods
-\*=========================================================================*/
-/*-------------------------------------------------------------------------*\
-* Just call buffered IO methods
-\*-------------------------------------------------------------------------*/
-static int meth_send(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixstream{client}", 1);
-    return buffer_meth_send(L, &un->buf);
-}
-
-static int meth_receive(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixstream{client}", 1);
-    return buffer_meth_receive(L, &un->buf);
-}
-
-static int meth_getstats(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixstream{client}", 1);
-    return buffer_meth_getstats(L, &un->buf);
-}
-
-static int meth_setstats(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixstream{client}", 1);
-    return buffer_meth_setstats(L, &un->buf);
-}
-
-/*-------------------------------------------------------------------------*\
-* Just call option handler
-\*-------------------------------------------------------------------------*/
-static int meth_setoption(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixstream{any}", 1);
-    return opt_meth_setoption(L, optset, &un->sock);
-}
-
-/*-------------------------------------------------------------------------*\
-* Select support methods
-\*-------------------------------------------------------------------------*/
-static int meth_getfd(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixstream{any}", 1);
-    lua_pushnumber(L, (int) un->sock);
-    return 1;
-}
-
-/* this is very dangerous, but can be handy for those that are brave enough */
-static int meth_setfd(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixstream{any}", 1);
-    un->sock = (t_socket) luaL_checknumber(L, 2);
-    return 0;
-}
-
-static int meth_dirty(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixstream{any}", 1);
-    lua_pushboolean(L, !buffer_isempty(&un->buf));
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Waits for and returns a client object attempting connection to the
-* server object
-\*-------------------------------------------------------------------------*/
-static int meth_accept(lua_State *L) {
-    p_unix server = (p_unix) auxiliar_checkclass(L, "unixstream{server}", 1);
-    p_timeout tm = timeout_markstart(&server->tm);
-    t_socket sock;
-    int err = socket_accept(&server->sock, &sock, NULL, NULL, tm);
-    /* if successful, push client socket */
-    if (err == IO_DONE) {
-        p_unix clnt = (p_unix) lua_newuserdata(L, sizeof(t_unix));
-        auxiliar_setclass(L, "unixstream{client}", -1);
-        /* initialize structure fields */
-        socket_setnonblocking(&sock);
-        clnt->sock = sock;
-        io_init(&clnt->io, (p_send)socket_send, (p_recv)socket_recv,
-                (p_error) socket_ioerror, &clnt->sock);
-        timeout_init(&clnt->tm, -1, -1);
-        buffer_init(&clnt->buf, &clnt->io, &clnt->tm);
-        return 1;
-    } else {
-        lua_pushnil(L);
-        lua_pushstring(L, socket_strerror(err));
-        return 2;
-    }
-}
-
-/*-------------------------------------------------------------------------*\
-* Binds an object to an address
-\*-------------------------------------------------------------------------*/
-static const char *unixstream_trybind(p_unix un, const char *path) {
-    struct sockaddr_un local;
-    size_t len = strlen(path);
-    int err;
-    if (len >= sizeof(local.sun_path)) return "path too long";
-    memset(&local, 0, sizeof(local));
-    strcpy(local.sun_path, path);
-    local.sun_family = AF_UNIX;
-#ifdef UNIX_HAS_SUN_LEN
-    local.sun_len = sizeof(local.sun_family) + sizeof(local.sun_len)
-        + len + 1;
-    err = socket_bind(&un->sock, (SA *) &local, local.sun_len);
-
-#else
-    err = socket_bind(&un->sock, (SA *) &local,
-            sizeof(local.sun_family) + len);
-#endif
-    if (err != IO_DONE) socket_destroy(&un->sock);
-    return socket_strerror(err);
-}
-
-static int meth_bind(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixstream{master}", 1);
-    const char *path =  luaL_checkstring(L, 2);
-    const char *err = unixstream_trybind(un, path);
-    if (err) {
-        lua_pushnil(L);
-        lua_pushstring(L, err);
-        return 2;
-    }
-    lua_pushnumber(L, 1);
-    return 1;
-}
-
-static int meth_getsockname(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixstream{any}", 1);
-    struct sockaddr_un peer = {0};
-    socklen_t peer_len = sizeof(peer);
-
-    if (getsockname(un->sock, (SA *) &peer, &peer_len) < 0) {
-        lua_pushnil(L);
-        lua_pushstring(L, socket_strerror(errno));
-        return 2;
-    }
-
-    lua_pushstring(L, peer.sun_path);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Turns a master unixstream object into a client object.
-\*-------------------------------------------------------------------------*/
-static const char *unixstream_tryconnect(p_unix un, const char *path)
-{
-    struct sockaddr_un remote;
-    int err;
-    size_t len = strlen(path);
-    if (len >= sizeof(remote.sun_path)) return "path too long";
-    memset(&remote, 0, sizeof(remote));
-    strcpy(remote.sun_path, path);
-    remote.sun_family = AF_UNIX;
-    timeout_markstart(&un->tm);
-#ifdef UNIX_HAS_SUN_LEN
-    remote.sun_len = sizeof(remote.sun_family) + sizeof(remote.sun_len)
-        + len + 1;
-    err = socket_connect(&un->sock, (SA *) &remote, remote.sun_len, &un->tm);
-#else
-    err = socket_connect(&un->sock, (SA *) &remote,
-            sizeof(remote.sun_family) + len, &un->tm);
-#endif
-    if (err != IO_DONE) socket_destroy(&un->sock);
-    return socket_strerror(err);
-}
-
-static int meth_connect(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixstream{master}", 1);
-    const char *path =  luaL_checkstring(L, 2);
-    const char *err = unixstream_tryconnect(un, path);
-    if (err) {
-        lua_pushnil(L);
-        lua_pushstring(L, err);
-        return 2;
-    }
-    /* turn master object into a client object */
-    auxiliar_setclass(L, "unixstream{client}", 1);
-    lua_pushnumber(L, 1);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Closes socket used by object
-\*-------------------------------------------------------------------------*/
-static int meth_close(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixstream{any}", 1);
-    socket_destroy(&un->sock);
-    lua_pushnumber(L, 1);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Puts the sockt in listen mode
-\*-------------------------------------------------------------------------*/
-static int meth_listen(lua_State *L)
-{
-    p_unix un = (p_unix) auxiliar_checkclass(L, "unixstream{master}", 1);
-    int backlog = (int) luaL_optnumber(L, 2, 32);
-    int err = socket_listen(&un->sock, backlog);
-    if (err != IO_DONE) {
-        lua_pushnil(L);
-        lua_pushstring(L, socket_strerror(err));
-        return 2;
-    }
-    /* turn master object into a server object */
-    auxiliar_setclass(L, "unixstream{server}", 1);
-    lua_pushnumber(L, 1);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Shuts the connection down partially
-\*-------------------------------------------------------------------------*/
-static int meth_shutdown(lua_State *L)
-{
-    /* SHUT_RD,  SHUT_WR,  SHUT_RDWR  have  the value 0, 1, 2, so we can use method index directly */
-    static const char* methods[] = { "receive", "send", "both", NULL };
-    p_unix stream = (p_unix) auxiliar_checkclass(L, "unixstream{client}", 1);
-    int how = luaL_checkoption(L, 2, "both", methods);
-    socket_shutdown(&stream->sock, how);
-    lua_pushnumber(L, 1);
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Just call tm methods
-\*-------------------------------------------------------------------------*/
-static int meth_settimeout(lua_State *L) {
-    p_unix un = (p_unix) auxiliar_checkgroup(L, "unixstream{any}", 1);
-    return timeout_meth_settimeout(L, &un->tm);
-}
-
-/*=========================================================================*\
-* Library functions
-\*=========================================================================*/
-/*-------------------------------------------------------------------------*\
-* Creates a master unixstream object
-\*-------------------------------------------------------------------------*/
-static int global_create(lua_State *L) {
-    t_socket sock;
-    int err = socket_create(&sock, AF_UNIX, SOCK_STREAM, 0);
-    /* try to allocate a system socket */
-    if (err == IO_DONE) {
-        /* allocate unixstream object */
-        p_unix un = (p_unix) lua_newuserdata(L, sizeof(t_unix));
-        /* set its type as master object */
-        auxiliar_setclass(L, "unixstream{master}", -1);
-        /* initialize remaining structure fields */
-        socket_setnonblocking(&sock);
-        un->sock = sock;
-        io_init(&un->io, (p_send) socket_send, (p_recv) socket_recv,
-                (p_error) socket_ioerror, &un->sock);
-        timeout_init(&un->tm, -1, -1);
-        buffer_init(&un->buf, &un->io, &un->tm);
-        return 1;
-    } else {
-        lua_pushnil(L);
-        lua_pushstring(L, socket_strerror(err));
-        return 2;
-    }
-}
diff --git a/unixstream.h b/unixstream.h
deleted file mode 100644
index 7916aff..0000000
--- a/unixstream.h
+++ /dev/null
@@ -1,29 +0,0 @@
-#ifndef UNIXSTREAM_H
-#define UNIXSTREAM_H
-/*=========================================================================*\
-* UNIX STREAM object
-* LuaSocket toolkit
-*
-* The unixstream.h module is basicly a glue that puts together modules buffer.h,
-* timeout.h socket.h and inet.h to provide the LuaSocket UNIX STREAM (AF_UNIX,
-* SOCK_STREAM) support.
-*
-* Three classes are defined: master, client and server. The master class is
-* a newly created unixstream object, that has not been bound or connected. Server
-* objects are unixstream objects bound to some local address. Client objects are
-* unixstream objects either connected to some address or returned by the accept
-* method of a server object.
-\*=========================================================================*/
-#include "unix.h"
-
-#ifndef _WIN32
-#pragma GCC visibility push(hidden)
-#endif
-
-int unixstream_open(lua_State *L);
-
-#ifndef _WIN32
-#pragma GCC visibility pop
-#endif
-
-#endif /* UNIXSTREAM_H */
diff --git a/usocket.c b/usocket.c
index 69635da..3cd8cde 100644
--- a/usocket.c
+++ b/usocket.c
@@ -18,7 +18,7 @@
 * Wait for readable/writable/connected socket with timeout
 \*-------------------------------------------------------------------------*/
 #ifndef SOCKET_SELECT
-#include <sys/poll.h>
+#include <poll.h>

 #define WAITFD_R        POLLIN
 #define WAITFD_W        POLLOUT
@@ -431,12 +431,16 @@ const char *socket_ioerror(p_socket ps, int err) {
 const char *socket_gaistrerror(int err) {
     if (err == 0) return NULL;
     switch (err) {
+#if !defined(__3DS__)
         case EAI_AGAIN: return PIE_AGAIN;
         case EAI_BADFLAGS: return PIE_BADFLAGS;
+#endif
 #ifdef EAI_BADHINTS
         case EAI_BADHINTS: return PIE_BADHINTS;
 #endif
+#if !defined(__3DS__)
         case EAI_FAIL: return PIE_FAIL;
+#endif
         case EAI_FAMILY: return PIE_FAMILY;
         case EAI_MEMORY: return PIE_MEMORY;
         case EAI_NONAME: return PIE_NONAME;
@@ -446,9 +450,13 @@ const char *socket_gaistrerror(int err) {
 #ifdef EAI_PROTOCOL
         case EAI_PROTOCOL: return PIE_PROTOCOL;
 #endif
+#if !defined(__3DS__)
         case EAI_SERVICE: return PIE_SERVICE;
+#endif
         case EAI_SOCKTYPE: return PIE_SOCKTYPE;
+#if !defined(__3DS__)
         case EAI_SYSTEM: return strerror(errno);
+#endif
         default: return LUA_GAI_STRERROR(err);
     }
 }
diff --git a/usocket.h b/usocket.h
index 45f2f99..12c25ca 100644
--- a/usocket.h
+++ b/usocket.h
@@ -29,7 +29,6 @@
 #include <arpa/inet.h>
 /* TCP options (nagle algorithm disable) */
 #include <netinet/tcp.h>
-#include <net/if.h>

 #ifndef SO_REUSEPORT
 #define SO_REUSEPORT SO_REUSEADDR
diff --git a/wsocket.c b/wsocket.c
deleted file mode 100755
index 6cb1e41..0000000
--- a/wsocket.c
+++ /dev/null
@@ -1,434 +0,0 @@
-/*=========================================================================*\
-* Socket compatibilization module for Win32
-* LuaSocket toolkit
-*
-* The penalty of calling select to avoid busy-wait is only paid when
-* the I/O call fail in the first place.
-\*=========================================================================*/
-#include "luasocket.h"
-
-#include <string.h>
-
-#include "socket.h"
-#include "pierror.h"
-
-/* WinSock doesn't have a strerror... */
-static const char *wstrerror(int err);
-
-/*-------------------------------------------------------------------------*\
-* Initializes module
-\*-------------------------------------------------------------------------*/
-int socket_open(void) {
-    WSADATA wsaData;
-    WORD wVersionRequested = MAKEWORD(2, 0);
-    int err = WSAStartup(wVersionRequested, &wsaData );
-    if (err != 0) return 0;
-    if ((LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 0) &&
-        (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1)) {
-        WSACleanup();
-        return 0;
-    }
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Close module
-\*-------------------------------------------------------------------------*/
-int socket_close(void) {
-    WSACleanup();
-    return 1;
-}
-
-/*-------------------------------------------------------------------------*\
-* Wait for readable/writable/connected socket with timeout
-\*-------------------------------------------------------------------------*/
-#define WAITFD_R        1
-#define WAITFD_W        2
-#define WAITFD_E        4
-#define WAITFD_C        (WAITFD_E|WAITFD_W)
-
-int socket_waitfd(p_socket ps, int sw, p_timeout tm) {
-    int ret;
-    fd_set rfds, wfds, efds, *rp = NULL, *wp = NULL, *ep = NULL;
-    struct timeval tv, *tp = NULL;
-    double t;
-    if (timeout_iszero(tm)) return IO_TIMEOUT;  /* optimize timeout == 0 case */
-    if (sw & WAITFD_R) {
-        FD_ZERO(&rfds);
-        FD_SET(*ps, &rfds);
-        rp = &rfds;
-    }
-    if (sw & WAITFD_W) { FD_ZERO(&wfds); FD_SET(*ps, &wfds); wp = &wfds; }
-    if (sw & WAITFD_C) { FD_ZERO(&efds); FD_SET(*ps, &efds); ep = &efds; }
-    if ((t = timeout_get(tm)) >= 0.0) {
-        tv.tv_sec = (int) t;
-        tv.tv_usec = (int) ((t-tv.tv_sec)*1.0e6);
-        tp = &tv;
-    }
-    ret = select(0, rp, wp, ep, tp);
-    if (ret == -1) return WSAGetLastError();
-    if (ret == 0) return IO_TIMEOUT;
-    if (sw == WAITFD_C && FD_ISSET(*ps, &efds)) return IO_CLOSED;
-    return IO_DONE;
-}
-
-/*-------------------------------------------------------------------------*\
-* Select with int timeout in ms
-\*-------------------------------------------------------------------------*/
-int socket_select(t_socket n, fd_set *rfds, fd_set *wfds, fd_set *efds,
-        p_timeout tm) {
-    struct timeval tv;
-    double t = timeout_get(tm);
-    tv.tv_sec = (int) t;
-    tv.tv_usec = (int) ((t - tv.tv_sec) * 1.0e6);
-    if (n <= 0) {
-        Sleep((DWORD) (1000*t));
-        return 0;
-    } else return select(0, rfds, wfds, efds, t >= 0.0? &tv: NULL);
-}
-
-/*-------------------------------------------------------------------------*\
-* Close and inutilize socket
-\*-------------------------------------------------------------------------*/
-void socket_destroy(p_socket ps) {
-    if (*ps != SOCKET_INVALID) {
-        socket_setblocking(ps); /* close can take a long time on WIN32 */
-        closesocket(*ps);
-        *ps = SOCKET_INVALID;
-    }
-}
-
-/*-------------------------------------------------------------------------*\
-*
-\*-------------------------------------------------------------------------*/
-void socket_shutdown(p_socket ps, int how) {
-    socket_setblocking(ps);
-    shutdown(*ps, how);
-    socket_setnonblocking(ps);
-}
-
-/*-------------------------------------------------------------------------*\
-* Creates and sets up a socket
-\*-------------------------------------------------------------------------*/
-int socket_create(p_socket ps, int domain, int type, int protocol) {
-    *ps = socket(domain, type, protocol);
-    if (*ps != SOCKET_INVALID) return IO_DONE;
-    else return WSAGetLastError();
-}
-
-/*-------------------------------------------------------------------------*\
-* Connects or returns error message
-\*-------------------------------------------------------------------------*/
-int socket_connect(p_socket ps, SA *addr, socklen_t len, p_timeout tm) {
-    int err;
-    /* don't call on closed socket */
-    if (*ps == SOCKET_INVALID) return IO_CLOSED;
-    /* ask system to connect */
-    if (connect(*ps, addr, len) == 0) return IO_DONE;
-    /* make sure the system is trying to connect */
-    err = WSAGetLastError();
-    if (err != WSAEWOULDBLOCK && err != WSAEINPROGRESS) return err;
-    /* zero timeout case optimization */
-    if (timeout_iszero(tm)) return IO_TIMEOUT;
-    /* we wait until something happens */
-    err = socket_waitfd(ps, WAITFD_C, tm);
-    if (err == IO_CLOSED) {
-        int elen = sizeof(err);
-        /* give windows time to set the error (yes, disgusting) */
-        Sleep(10);
-        /* find out why we failed */
-        getsockopt(*ps, SOL_SOCKET, SO_ERROR, (char *)&err, &elen);
-        /* we KNOW there was an error. if 'why' is 0, we will return
-        * "unknown error", but it's not really our fault */
-        return err > 0? err: IO_UNKNOWN;
-    } else return err;
-
-}
-
-/*-------------------------------------------------------------------------*\
-* Binds or returns error message
-\*-------------------------------------------------------------------------*/
-int socket_bind(p_socket ps, SA *addr, socklen_t len) {
-    int err = IO_DONE;
-    socket_setblocking(ps);
-    if (bind(*ps, addr, len) < 0) err = WSAGetLastError();
-    socket_setnonblocking(ps);
-    return err;
-}
-
-/*-------------------------------------------------------------------------*\
-*
-\*-------------------------------------------------------------------------*/
-int socket_listen(p_socket ps, int backlog) {
-    int err = IO_DONE;
-    socket_setblocking(ps);
-    if (listen(*ps, backlog) < 0) err = WSAGetLastError();
-    socket_setnonblocking(ps);
-    return err;
-}
-
-/*-------------------------------------------------------------------------*\
-* Accept with timeout
-\*-------------------------------------------------------------------------*/
-int socket_accept(p_socket ps, p_socket pa, SA *addr, socklen_t *len,
-        p_timeout tm) {
-    if (*ps == SOCKET_INVALID) return IO_CLOSED;
-    for ( ;; ) {
-        int err;
-        /* try to get client socket */
-        if ((*pa = accept(*ps, addr, len)) != SOCKET_INVALID) return IO_DONE;
-        /* find out why we failed */
-        err = WSAGetLastError();
-        /* if we failed because there was no connectoin, keep trying */
-        if (err != WSAEWOULDBLOCK && err != WSAECONNABORTED) return err;
-        /* call select to avoid busy wait */
-        if ((err = socket_waitfd(ps, WAITFD_R, tm)) != IO_DONE) return err;
-    }
-}
-
-/*-------------------------------------------------------------------------*\
-* Send with timeout
-* On windows, if you try to send 10MB, the OS will buffer EVERYTHING
-* this can take an awful lot of time and we will end up blocked.
-* Therefore, whoever calls this function should not pass a huge buffer.
-\*-------------------------------------------------------------------------*/
-int socket_send(p_socket ps, const char *data, size_t count,
-        size_t *sent, p_timeout tm)
-{
-    int err;
-    *sent = 0;
-    /* avoid making system calls on closed sockets */
-    if (*ps == SOCKET_INVALID) return IO_CLOSED;
-    /* loop until we send something or we give up on error */
-    for ( ;; ) {
-        /* try to send something */
-        int put = send(*ps, data, (int) count, 0);
-        /* if we sent something, we are done */
-        if (put > 0) {
-            *sent = put;
-            return IO_DONE;
-        }
-        /* deal with failure */
-        err = WSAGetLastError();
-        /* we can only proceed if there was no serious error */
-        if (err != WSAEWOULDBLOCK) return err;
-        /* avoid busy wait */
-        if ((err = socket_waitfd(ps, WAITFD_W, tm)) != IO_DONE) return err;
-    }
-}
-
-/*-------------------------------------------------------------------------*\
-* Sendto with timeout
-\*-------------------------------------------------------------------------*/
-int socket_sendto(p_socket ps, const char *data, size_t count, size_t *sent,
-        SA *addr, socklen_t len, p_timeout tm)
-{
-    int err;
-    *sent = 0;
-    if (*ps == SOCKET_INVALID) return IO_CLOSED;
-    for ( ;; ) {
-        int put = sendto(*ps, data, (int) count, 0, addr, len);
-        if (put > 0) {
-            *sent = put;
-            return IO_DONE;
-        }
-        err = WSAGetLastError();
-        if (err != WSAEWOULDBLOCK) return err;
-        if ((err = socket_waitfd(ps, WAITFD_W, tm)) != IO_DONE) return err;
-    }
-}
-
-/*-------------------------------------------------------------------------*\
-* Receive with timeout
-\*-------------------------------------------------------------------------*/
-int socket_recv(p_socket ps, char *data, size_t count, size_t *got,
-        p_timeout tm)
-{
-    int err, prev = IO_DONE;
-    *got = 0;
-    if (*ps == SOCKET_INVALID) return IO_CLOSED;
-    for ( ;; ) {
-        int taken = recv(*ps, data, (int) count, 0);
-        if (taken > 0) {
-            *got = taken;
-            return IO_DONE;
-        }
-        if (taken == 0) return IO_CLOSED;
-        err = WSAGetLastError();
-        /* On UDP, a connreset simply means the previous send failed.
-         * So we try again.
-         * On TCP, it means our socket is now useless, so the error passes.
-         * (We will loop again, exiting because the same error will happen) */
-        if (err != WSAEWOULDBLOCK) {
-            if (err != WSAECONNRESET || prev == WSAECONNRESET) return err;
-            prev = err;
-        }
-        if ((err = socket_waitfd(ps, WAITFD_R, tm)) != IO_DONE) return err;
-    }
-}
-
-/*-------------------------------------------------------------------------*\
-* Recvfrom with timeout
-\*-------------------------------------------------------------------------*/
-int socket_recvfrom(p_socket ps, char *data, size_t count, size_t *got,
-        SA *addr, socklen_t *len, p_timeout tm)
-{
-    int err, prev = IO_DONE;
-    *got = 0;
-    if (*ps == SOCKET_INVALID) return IO_CLOSED;
-    for ( ;; ) {
-        int taken = recvfrom(*ps, data, (int) count, 0, addr, len);
-        if (taken > 0) {
-            *got = taken;
-            return IO_DONE;
-        }
-        if (taken == 0) return IO_CLOSED;
-        err = WSAGetLastError();
-        /* On UDP, a connreset simply means the previous send failed.
-         * So we try again.
-         * On TCP, it means our socket is now useless, so the error passes.
-         * (We will loop again, exiting because the same error will happen) */
-        if (err != WSAEWOULDBLOCK) {
-            if (err != WSAECONNRESET || prev == WSAECONNRESET) return err;
-            prev = err;
-        }
-        if ((err = socket_waitfd(ps, WAITFD_R, tm)) != IO_DONE) return err;
-    }
-}
-
-/*-------------------------------------------------------------------------*\
-* Put socket into blocking mode
-\*-------------------------------------------------------------------------*/
-void socket_setblocking(p_socket ps) {
-    u_long argp = 0;
-    ioctlsocket(*ps, FIONBIO, &argp);
-}
-
-/*-------------------------------------------------------------------------*\
-* Put socket into non-blocking mode
-\*-------------------------------------------------------------------------*/
-void socket_setnonblocking(p_socket ps) {
-    u_long argp = 1;
-    ioctlsocket(*ps, FIONBIO, &argp);
-}
-
-/*-------------------------------------------------------------------------*\
-* DNS helpers
-\*-------------------------------------------------------------------------*/
-int socket_gethostbyaddr(const char *addr, socklen_t len, struct hostent **hp) {
-    *hp = gethostbyaddr(addr, len, AF_INET);
-    if (*hp) return IO_DONE;
-    else return WSAGetLastError();
-}
-
-int socket_gethostbyname(const char *addr, struct hostent **hp) {
-    *hp = gethostbyname(addr);
-    if (*hp) return IO_DONE;
-    else return  WSAGetLastError();
-}
-
-/*-------------------------------------------------------------------------*\
-* Error translation functions
-\*-------------------------------------------------------------------------*/
-const char *socket_hoststrerror(int err) {
-    if (err <= 0) return io_strerror(err);
-    switch (err) {
-        case WSAHOST_NOT_FOUND: return PIE_HOST_NOT_FOUND;
-        default: return wstrerror(err);
-    }
-}
-
-const char *socket_strerror(int err) {
-    if (err <= 0) return io_strerror(err);
-    switch (err) {
-        case WSAEADDRINUSE: return PIE_ADDRINUSE;
-        case WSAECONNREFUSED : return PIE_CONNREFUSED;
-        case WSAEISCONN: return PIE_ISCONN;
-        case WSAEACCES: return PIE_ACCESS;
-        case WSAECONNABORTED: return PIE_CONNABORTED;
-        case WSAECONNRESET: return PIE_CONNRESET;
-        case WSAETIMEDOUT: return PIE_TIMEDOUT;
-        default: return wstrerror(err);
-    }
-}
-
-const char *socket_ioerror(p_socket ps, int err) {
-    (void) ps;
-    return socket_strerror(err);
-}
-
-static const char *wstrerror(int err) {
-    switch (err) {
-        case WSAEINTR: return "Interrupted function call";
-        case WSAEACCES: return PIE_ACCESS; /* "Permission denied"; */
-        case WSAEFAULT: return "Bad address";
-        case WSAEINVAL: return "Invalid argument";
-        case WSAEMFILE: return "Too many open files";
-        case WSAEWOULDBLOCK: return "Resource temporarily unavailable";
-        case WSAEINPROGRESS: return "Operation now in progress";
-        case WSAEALREADY: return "Operation already in progress";
-        case WSAENOTSOCK: return "Socket operation on nonsocket";
-        case WSAEDESTADDRREQ: return "Destination address required";
-        case WSAEMSGSIZE: return "Message too long";
-        case WSAEPROTOTYPE: return "Protocol wrong type for socket";
-        case WSAENOPROTOOPT: return "Bad protocol option";
-        case WSAEPROTONOSUPPORT: return "Protocol not supported";
-        case WSAESOCKTNOSUPPORT: return PIE_SOCKTYPE; /* "Socket type not supported"; */
-        case WSAEOPNOTSUPP: return "Operation not supported";
-        case WSAEPFNOSUPPORT: return "Protocol family not supported";
-        case WSAEAFNOSUPPORT: return PIE_FAMILY; /* "Address family not supported by protocol family"; */
-        case WSAEADDRINUSE: return PIE_ADDRINUSE; /* "Address already in use"; */
-        case WSAEADDRNOTAVAIL: return "Cannot assign requested address";
-        case WSAENETDOWN: return "Network is down";
-        case WSAENETUNREACH: return "Network is unreachable";
-        case WSAENETRESET: return "Network dropped connection on reset";
-        case WSAECONNABORTED: return "Software caused connection abort";
-        case WSAECONNRESET: return PIE_CONNRESET; /* "Connection reset by peer"; */
-        case WSAENOBUFS: return "No buffer space available";
-        case WSAEISCONN: return PIE_ISCONN; /* "Socket is already connected"; */
-        case WSAENOTCONN: return "Socket is not connected";
-        case WSAESHUTDOWN: return "Cannot send after socket shutdown";
-        case WSAETIMEDOUT: return PIE_TIMEDOUT; /* "Connection timed out"; */
-        case WSAECONNREFUSED: return PIE_CONNREFUSED; /* "Connection refused"; */
-        case WSAEHOSTDOWN: return "Host is down";
-        case WSAEHOSTUNREACH: return "No route to host";
-        case WSAEPROCLIM: return "Too many processes";
-        case WSASYSNOTREADY: return "Network subsystem is unavailable";
-        case WSAVERNOTSUPPORTED: return "Winsock.dll version out of range";
-        case WSANOTINITIALISED:
-            return "Successful WSAStartup not yet performed";
-        case WSAEDISCON: return "Graceful shutdown in progress";
-        case WSAHOST_NOT_FOUND: return PIE_HOST_NOT_FOUND; /* "Host not found"; */
-        case WSATRY_AGAIN: return "Nonauthoritative host not found";
-        case WSANO_RECOVERY: return PIE_FAIL; /* "Nonrecoverable name lookup error"; */
-        case WSANO_DATA: return "Valid name, no data record of requested type";
-        default: return "Unknown error";
-    }
-}
-
-const char *socket_gaistrerror(int err) {
-    if (err == 0) return NULL;
-    switch (err) {
-        case EAI_AGAIN: return PIE_AGAIN;
-        case EAI_BADFLAGS: return PIE_BADFLAGS;
-#ifdef EAI_BADHINTS
-        case EAI_BADHINTS: return PIE_BADHINTS;
-#endif
-        case EAI_FAIL: return PIE_FAIL;
-        case EAI_FAMILY: return PIE_FAMILY;
-        case EAI_MEMORY: return PIE_MEMORY;
-        case EAI_NONAME: return PIE_NONAME;
-#ifdef EAI_OVERFLOW
-        case EAI_OVERFLOW: return PIE_OVERFLOW;
-#endif
-#ifdef EAI_PROTOCOL
-        case EAI_PROTOCOL: return PIE_PROTOCOL;
-#endif
-        case EAI_SERVICE: return PIE_SERVICE;
-        case EAI_SOCKTYPE: return PIE_SOCKTYPE;
-#ifdef EAI_SYSTEM
-        case EAI_SYSTEM: return strerror(errno);
-#endif
-        default: return LUA_GAI_STRERROR(err);
-    }
-}
diff --git a/wsocket.h b/wsocket.h
deleted file mode 100644
index 3986640..0000000
--- a/wsocket.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef WSOCKET_H
-#define WSOCKET_H
-/*=========================================================================*\
-* Socket compatibilization module for Win32
-* LuaSocket toolkit
-\*=========================================================================*/
-
-/*=========================================================================*\
-* WinSock include files
-\*=========================================================================*/
-#include <winsock2.h>
-#include <ws2tcpip.h>
-
-typedef int socklen_t;
-typedef SOCKADDR_STORAGE t_sockaddr_storage;
-typedef SOCKET t_socket;
-typedef t_socket *p_socket;
-
-#ifndef IPV6_V6ONLY
-#define IPV6_V6ONLY 27
-#endif
-
-#define SOCKET_INVALID (INVALID_SOCKET)
-
-#ifndef SO_REUSEPORT
-#define SO_REUSEPORT SO_REUSEADDR
-#endif
-
-#ifndef AI_NUMERICSERV
-#define AI_NUMERICSERV (0)
-#endif
-
-#endif /* WSOCKET_H */
